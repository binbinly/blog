## 安装

### 下载

- [官方下载](https://nodejs.org/en/download/current)

### 二进制包安装

+ [文档](https://github.com/nodejs/help/wiki/Installation)
+ 
```bash
# 选择 LTS 版本的二进制包
wget https://nodejs.org/dist/v20.9.0/node-v20.9.0-linux-x64.tar.xz  
# 解压
mkdir -p /usr/local/nodejs
tar -xJvf node-v20.9.0-linux-x64.tar.xz  -C /usr/local/nodejs    
cd node-v20.9.0-linux-x64
# check
./bin/node -v 
```
设置环境变量 `~/.profile` or `/etc/profile`
```bash
export PATH=/usr/local/lib/nodejs/nodejs/bin:$PATH
```
```bash
node -v
npm version
npm -v
```

## 介绍

- Node.js 是一个基于 `Chrome V8` 引擎的 `JavaScript` 运行时环境，用于构建快速、可扩展的网络应用程序。它允许开发人员使用 `JavaScript` 编程语言来编写服务器端应用程序，与传统的浏览器端 JavaScript 不同。Node.js 提供了丰富的内置库，使开发者可以轻松处理文件操作、网络通信、HTTP 请求、数据库访问等任务。
- Node.js 采用事件驱动的非阻塞 I/O 模型，这意味着它可以处理大量并发请求而不阻塞应用程序的执行。这使得 Node.js 特别适用于构建实时应用程序、聊天应用、在线游戏、数据流处理和其他需要高性能的应用。

## 内置模块

### path

> [官方文档](https://nodejs.cn/api/path)

* `__filename`。全局值，当前文件绝对路径
* `__dirname`。全局值，当前文件夹绝对路径。等效于path.resolve(__filename, '..')
* `path.join([...paths])`。相当于把所传入的任意多的参数 按照顺序 进行命令行般的推进
* `path.resolve([...paths])`。方法将路径或路径片段的序列解析为绝对路径。
* `path.dirname(path)`。返回指定路径**所在文件夹的路径**
* `path.basename(path)`。返回指定Path路径**所在文件的名字**
* `path.extname(path)`。获取指定字符串或者文件路径**名字的后缀名**，带.比如.txt
* `path.isAbsolute(path)` 是否是绝对路径,返回boolean值

``` js
path.join('a','b','../c/lolo') // a/c/lolo

path.resolve('/foo/bar', './baz'); // Returns: '/foo/bar/baz'
path.resolve('/foo/bar', '/tmp/file/'); // Returns: '/tmp/file'

const filePath = './bar/baz/asdf/quux.html'
path.basename(filePath) // quux.html
path.dirname(filePath) // ./bar/baz/asdf
path.extname(filePath) // .html
path.isAbsolute(filePath) // false
```

### url

> [官方文档](https://nodejs.cn/api/url)

url 模块提供了两套 API 来处理 URL 字符串：一个是Node.js特有的API，是旧版本的遗留；另一个则是实现了WHATWG URL Standard的 API (const {URL} = require('url')方式)，该标准也在各种浏览器中被使用。

+ 使用 WHATWG API 解析网址字符串：
```js
const myURL =
  new URL('https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'); 
```
+ 使用旧版 API 解析 URL 字符串：
```js
const url = require('node:url');
const myURL =
  url.parse('https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash');
```

### querystring

> [官方文档](https://nodejs.cn/api/querystring.html)

* `querystring.parse`。一个URL查询字符串 str 解析成一个键值对的集合。
``` js
const querystring = require('querystring')
let query = querystring.parse('type=123')
console.log(query) // { type: '123' }
```
* `querystring.stringify`。遍历给定的 obj 对象的自身属性，生成 URL 查询字符串。
```js
querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });
// Returns 'foo=bar&baz=qux&baz=quux&corge='
querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');
// Returns 'foo:bar;baz:qux' 
```

### Stream

> [官方文档](https://nodejs.cn/api/stream.html)

- 流是用于在 Node.js 中处理流数据的抽象接口。 `node:stream` 模块提供了用于实现流接口的 API。
- Node.js 提供了许多流对象。 例如，a `向 HTTP 服务器请求` 和 `process.stdout` 都是流实例。
- 流可以是可读的、可写的、或两者兼而有之。 所有的流都是 `EventEmitter` 的实例。

```js
const stream = require('node:stream'); 
```

#### 流的类型

Node.js 中有四种基本的流类型：

- `Writable`: 可以写入数据的流（例如，fs.createWriteStream()）。
- `Readable`: 可以从中读取数据的流（例如，fs.createReadStream()）。
- `Duplex`: Readable 和 Writable 的流（例如，net.Socket）。
- `Transform`: 可以在写入和读取数据时修改或转换数据的 Duplex 流（例如，zlib.createDeflate()）。

> 此外，此模块还包括实用函数 `stream.pipeline()`、`stream.finished()`、`stream.Readable.from()` 和 `stream.addAbortSignal()`。

### http

> [官方文档](https://nodejs.cn/api/http.html)

- 要使用 HTTP 服务器和客户端，则必须 `require('node:http')`。
- Node.js 中的 HTTP 接口旨在支持该协议的许多传统上难以使用的功能。 特别是大的，可能是块编码的消息。 接口从不缓冲整个请求或响应，因此用户能够流式传输数据。

演示如何监听 `connect` 事件的客户端和服务器对：
```js
const http = require('node:http');
const net = require('node:net');
const { URL } = require('node:url');

// Create an HTTP tunneling proxy
const proxy = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('okay');
});
proxy.on('connect', (req, clientSocket, head) => {
  // Connect to an origin server
  const { port, hostname } = new URL(`http://${req.url}`);
  const serverSocket = net.connect(port || 80, hostname, () => {
    clientSocket.write('HTTP/1.1 200 Connection Established\r\n' +
                    'Proxy-agent: Node.js-Proxy\r\n' +
                    '\r\n');
    serverSocket.write(head);
    serverSocket.pipe(clientSocket);
    clientSocket.pipe(serverSocket);
  });
});

// Now that proxy is running
proxy.listen(1337, '127.0.0.1', () => {

  // Make a request to a tunneling proxy
  const options = {
    port: 1337,
    host: '127.0.0.1',
    method: 'CONNECT',
    path: 'www.google.com:80',
  };

  const req = http.request(options);
  req.end();

  req.on('connect', (res, socket, head) => {
    console.log('got connected!');

    // Make a request over an HTTP tunnel
    socket.write('GET / HTTP/1.1\r\n' +
                 'Host: www.google.com:80\r\n' +
                 'Connection: close\r\n' +
                 '\r\n');
    socket.on('data', (chunk) => {
      console.log(chunk.toString());
    });
    socket.on('end', () => {
      proxy.close();
    });
  });
});
```

### buffer

> [官方文档](https://nodejs.cn/api/buffer.html)

- `Buffer` 对象用于表示固定长度的字节序列。 许多 Node.js API 都支持 Buffer。
- `Buffer` 类是 JavaScript `Uint8Array` 类的子类，并使用涵盖额外用例的方法对其进行扩展。 Node.js API 在支持 Buffer 的地方也接受纯 `Uint8Array`
- 虽然 Buffer 类在全局作用域内可用，但仍然建议通过 `import` 或 `require` 语句显式地引用它。
  
```js
const { Buffer } = require('node:buffer');
```

``` js
const { Buffer } = require('node:buffer');

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer's
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
// are all truncated using `(value & 255)` to fit into the range 0–255.
const buf5 = Buffer.from([257, 257.5, -255, '1']);

// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from('tést');

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from('tést', 'latin1');
```

## [File System](https://nodejs.org/dist/latest-v11.x/docs/api/fs.html)

* `file文件操作`
    * **readFile(path[, options], callback)**
        * 没有指定 encoding，则返回原始的 buffer
    * **writeFile(file, data[, options], callback)**
        * 如果文件已存在，则覆盖文件。
        * data支持 string/Buffer/TypedArray/DataView
        * data 是一个 buffer，则忽略 encoding
    * copyFile(src, dest[, flags], callback)

    * rename(oldPath, newPath, callback)。文件重命名
    * write(fd, string[, positinon[, encoding]], callback)。将 string 写入到 fd 指定的文件写文件
    * exists(url, callback(boolean))<sup>`Deprecated`</sup>。查询是否存在，`一般用在单纯检查文件`而不去操作(open/readFile/writeFile等操作文件不成立时会回调err)文件时。推荐使用fs.stat() or fs.access() 代替该方法。
    * **stat(path[, options],callback(err, stat))**。查询文件/目录信息
        * stat.isFile 是否一个普通文件
        * stat.isDirectory 是否一个目录
        * stat.ctime 最后一次修改文件的时间

    * createReadStream(path[, options])。 指定路径读取，获得Readable Stream。
    * createWriteStream(path[, options])。创建空的写入流到目标路径，获得Writeable Stream。
* `dir目录操作`
    * **readdir(path[, options], callback)**。读目录，获取目录下的`所有文件和文件夹`名称。
    * rmdir(path, callback)。移除目录
> 文件操作的path参数，绝对路径和相对路径都支持（相对路径基于process.cwd()）。

``` js
const fs = require('fs')
const path = require('path')
let dir = './node/snapshot'
fs.readFile(path.join(dir, 'test1.png'), (err, data) => {
    console.log(Buffer.isBuffer(data)) // true

    fs.writeFile(path.join(dir, 'test1_copy.png'), data, (error) => console.log(error)
})
```

## [Process](https://nodejs.org/api/process.html)<sup>`global`</sup>

process对象是一个提供当前node进程信息的全局对象，所以该对象不需要require()引入。process同时也是[EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)（典型的发布订阅模式案例）的一个实例，所以有.on()等方法。

* `process.argv`。一个包含命令行参数的数组。第一个元素是’node’，第二个元素是JavaScript文件的文件名。接下来的元素则是附加的命令行参数。

    ``` js
    // process.js
    process.argv.forEach(function(val, index, array) {
    console.log(index + ': ' + val);
    });

    // output
    $ node process.js one two=three four
    0: node
    1: /Users/node/process.js
    2: one
    3: two=three
    4: four
    ```

* `process.env`。返回用户设置的环境变量。

    ``` js
    // index.js
    console.log(process.env.NODE_ENV) // production

    // output
    $ cross-env NODE_ENV=production node index
    production
    ```

* `process.cwd()`。返回当前进程的工作目录
    > 和 __dirname 不同, __dirname 返回的是当前文件的所在目录

* `process.exit()`。退出当前程序。
    >当执行exit()方法时，可以使用`process.on('exit', callback)`作为退出程序前的清理工作。

* `process signal Events`。当[标准POSIX信号](http://man7.org/linux/man-pages/man7/signal.7.html)被触发(通常是process.kill(signal)或Ctrl+C等操作)，nodejs进程可以通过监听对应信号来进行回调。
    * `SIGINT`：interrupt，程序终止信号，通常在用户按下CTRL+C时发出，用来通知前台进程终止进程。
    * `SIGTERM`：terminate，程序结束信号，通常用来要求程序自己正常退出。process.kill()缺省产生这个信号。

## [child_process](http://nodejs.cn/api/child_process.html)

子程序，在node中，child_process这个模块非常重要。熟悉shell脚本的同学，可以用它的异步特性完成很多事情。

异步`创建子程序`有四种方式，后三种底层都是spawn实现的:
* child_process.spawn(command[, args][, options])
* child_process.exec(command[, options][, callback])
* child_process.execFile(file[, args][, options][, callback])
* child_process.fork(modulePath[, args][, options])

### create child_process

* `child_process.spawn`。Node.js 的父进程与衍生的子进程之间会建立 stdin、stdout 和 stderr 的管道。
    * `options.stdio`: stdio(标准输入输出) 用来配置子进程和父进程之间的 IO 通道,可以传递一个数组或者字符串。如，['pipe', 'pipe', 'pipe']，分别配置：标准输入、标准输出、标准错误。如果传递字符串，则三者将被配置成一样的值。简要介绍其中三个可以取的值：
        * `pipe（默认）`：父子进程间建立 pipe 通道，可以通过 stream 的方式来操作 IO
        * `inherit`：子进程直接使用父进程的 IO(该种情况使用较多,子进程命令中，执行的node文件里使用process对象与主文件中一致)
        * `ignore`：不建立 pipe 通道，不能 pipe、不能监听 data 事件、IO 全被忽略
``` js
const { spawn } = require('child_process');
var ls = spawn('ls', ['-al'],{
    stdio: 'inherit'
});

ls.stdout.on('data', function(data){
    console.log('data from child: ' + data);
});


ls.stderr.on('data', function(data){
    console.log('error from child: ' + data);
});

ls.on('close', function(code){
    console.log('child exists with code: ' + code);
});
```
* `child_process.exec`。创建一个shell，然后在shell里执行命令。执行完成后，将stdout、stderr作为参数传入回调方法。exec 比较适合用来执行 shell 命令，然后获取输出。
``` js
const { exec } = require('child_process');

exec('ls -al', function(error, stdout, stderr){
    if(error) {
        console.error('error: ' + error);
        return;
    }
    console.log('stdout: ' + stdout);
    console.log('stderr: ' + typeof stderr);
});
```
* `events`。child_process支持以下事件：
    * `exit`。子进程退出。注意其和close的区别，当exit触发时，其stdio流有可能还打开着，可以在此时做一些清理工作。通常情况下，child_process.kill()会触发该事件。
    * `close`。当子进程关闭时。通常情况下，child_process.kill()也会触发该事件。
    * `error`。当子进程不能关闭时，关闭它会报error事件。调用kill()可能会触发该事件。
    * `message`。跟child_process.send方法有关,父子进程间通信。
    * `disconnect`。跟child_process.disconnect方法有关。

``` js
var child_process = require('child_process')

var proc = child_process.spawn('pm2-runtime', ['proxy-server', '--', './dist'], { stdio: 'inherit' })

process.on('SIGTERM', () => proc.kill('SIGTERM'))
process.on('SIGINT', () => proc.kill('SIGINT'))
process.on('SIGBREAK', () => proc.kill('SIGBREAK'))
process.on('SIGHUP', () => proc.kill('SIGHUP'))

proc.on('exit', process.exit)
```

### [assert]()
* `assert(value[, message])` assert.ok()的别名
* `assert.equal(actual, expected[, message])` 比较是否相等。equal是非严格模式，官方推荐使用严格模式assert.strictEqual()。
* assert.notEqual(actual, expected[, message])
* `assert.ok(value[, message])` 测试 value 是否为真值。相当于 assert.equal(!!value, true, message)
* `assert.fail([message])` 抛出 AssertionError，并带上提供的错误信息或默认的错误信息。

```js
assert.equal(1, '1'); // OK, 1 == '1'
assert.notEqual(1, 2); // OK
assert.ok(1); // 测试通过。
assert.ok(typeof 123 === 'string'); // // 抛出 AssertionError: false == true
assert.fail('失败'); // 抛出 AssertionError [ERR_ASSERTION]: 失败
```
## 参考文章

* [Nodejs进阶：如何玩转子进程（child_process）](https://www.cnblogs.com/chyingp/p/node-learning-guide-child_process.html)
